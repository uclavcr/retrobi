/*
 * Copyright 2012 UCL AV CR v.v.i.
 *
 * This file is part of Retrobi.
 *
 * Retrobi is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Retrobi is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Retrobi. If not, see <http://www.gnu.org/licenses/>.
 */

package cz.insophy.retrobi.database;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.jcouchdb.db.Database;
import org.jcouchdb.db.Options;
import org.jcouchdb.document.ValueRow;
import org.jcouchdb.document.View;
import org.jcouchdb.document.ViewResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import cz.insophy.retrobi.database.entity.Card;
import cz.insophy.retrobi.database.entity.Time;
import cz.insophy.retrobi.database.entity.type.BatchMetainfo;
import cz.insophy.retrobi.database.entity.type.CardState;
import cz.insophy.retrobi.database.entity.type.Catalog;
import cz.insophy.retrobi.exception.GeneralRepositoryException;
import cz.insophy.retrobi.exception.NotFoundRepositoryException;
import cz.insophy.retrobi.utils.CzechAlphabet;
import cz.insophy.retrobi.utils.library.SimpleGeneralUtils;

/**
 * Class that provides access to the card library. Library consists of several
 * card catalogs. Each catalog contains batches. Every card is either defined by
 * catalog, batch and its number in it (order), or by its ID. The ID is
 * automatically generated by the CouchDB database. The card repository can
 * manipulate with all entities in the catalog.
 * 
 * @author Vojtěch Hordějčuk
 */
final public class CardRepository extends AbstractRepository {
    /**
     * logger instance
     */
    private static final Logger LOG = LoggerFactory.getLogger(CardRepository.class);
    /**
     * batches size view name
     */
    private static final String V_BATCHES_SIZE = "batches_size";
    /**
     * batches view name
     */
    private static final String V_BATCHES = "batches";
    /**
     * cards view name
     */
    private static final String V_CARDS = "cards";
    /**
     * files view name
     */
    private static final String V_FILES = "files";
    /**
     * OCR fixes view name
     */
    private static final String V_REWRITES = "ocr_fixes";
    
    /**
     * Creates a new instance.
     * 
     * @param database
     * database object
     */
    protected CardRepository(final Database database) {
        super(database);
    }
    
    /**
     * Adds a new card into the database.
     * 
     * @param card
     * a card to be added
     * @throws GeneralRepositoryException
     * general repository exception
     */
    public void addCard(final Card card) throws GeneralRepositoryException {
        CardRepository.LOG.debug("Adding card...");
        card.setAdded(Time.now());
        card.setUpdated(Time.now());
        this.createDocument(card);
        CardRepository.LOG.debug("Card added.");
    }
    
    /**
     * Updates the card in the database.
     * 
     * @param card
     * a card to be updated
     * @throws GeneralRepositoryException
     * repository exception
     */
    public void updateCard(final Card card) throws GeneralRepositoryException {
        CardRepository.LOG.debug("Updating card...");
        card.setUpdated(Time.now());
        this.updateDocument(card);
        CardRepository.LOG.debug("Card updated.");
    }
    
    /**
     * Removes the card from the database. Does not renumber the batch. Use with
     * caution and always renumber the batch after removing.
     * 
     * @param card
     * card to be removed
     * @throws GeneralRepositoryException
     * repository exception
     */
    public void deleteCard(final Card card) throws GeneralRepositoryException {
        CardRepository.LOG.debug("Deleting card...");
        this.deleteDocument(card);
        CardRepository.LOG.debug("Card deleted.");
    }
    
    /**
     * Checks if the card with the given ID exists.
     * 
     * @param cardId
     * card ID
     * @return <code>true</code> if the card exists, <code>false</code>
     * otherwise
     */
    public boolean cardExists(final String cardId) {
        if ((cardId == null) || (cardId.length() != 32)) {
            CardRepository.LOG.warn("Invalid card ID: " + cardId);
            return false;
        }
        
        try {
            if (this.loadDocument(Card.class, cardId) != null) {
                return true;
            }
        } catch (final Exception x) {
            // NOP
        }
        
        return false;
    }
    
    /**
     * Loads the card with the given ID from the database.
     * 
     * @param cardId
     * card ID
     * @return a card loaded
     * @throws NotFoundRepositoryException
     * not found repository exception
     * @throws GeneralRepositoryException
     * repository exception
     */
    public Card getCard(final String cardId) throws NotFoundRepositoryException, GeneralRepositoryException {
        CardRepository.LOG.debug(String.format("Loading card '%s'...", cardId));
        return this.loadDocument(Card.class, cardId);
    }
    
    /**
     * Loads a list of cards by their IDs.
     * 
     * @param cardIds
     * card IDs
     * @return list of cards
     * @throws GeneralRepositoryException
     * general repository exception
     * @throws NotFoundRepositoryException
     * not found repository exception
     */
    public List<Card> getCards(final List<String> cardIds) throws NotFoundRepositoryException, GeneralRepositoryException {
        CardRepository.LOG.debug(String.format("Loading %d document(s)...", cardIds.size()));
        return this.loadDocuments(Card.class, cardIds);
    }
    
    /**
     * Returns the list of card IDs from the given batch and catalog. This
     * method is pretty flexible, see parameters.
     * 
     * @param catalog
     * catalog
     * @param batch
     * batch
     * @param offset
     * number of cards to skip from the beginning
     * @param limit
     * maximal card count (zero means "no limit")
     * @return list of card IDs
     * @throws GeneralRepositoryException
     * general exception
     */
    public List<String> getCardIds(final Catalog catalog, final String batch, final int offset, final int limit) throws GeneralRepositoryException {
        CardRepository.LOG.debug(String.format("Loading cards from batch '%s' in catalog '%s'...", batch, catalog));
        CardRepository.LOG.debug(String.format("(offset %d, limit %d)", offset, limit));
        
        // PREPARE QUERY
        
        final Object startKey = new Object[] { catalog.name(), batch };
        final Object endKey = new Object[] { catalog.name(), batch, Collections.emptyMap() };
        
        final Options options = new Options().startKey(startKey).endKey(endKey).skip(offset);
        
        if (limit > 0) {
            options.limit(limit);
        }
        
        // RETURN RESULTS
        
        return this.loadDocumentIds(CardRepository.V_CARDS, options);
    }
    
    /**
     * Returns all card IDs from the given batch.
     * 
     * @param catalog
     * catalog
     * @param batch
     * batch
     * @return list of all card IDs in the batch
     * @throws GeneralRepositoryException
     * general exception
     */
    public List<String> getCardIdsInBatch(final Catalog catalog, final String batch) throws GeneralRepositoryException {
        return this.getCardIds(catalog, batch, 0, -1);
    }
    
    /**
     * Returns the list of card IDs from the given batch and catalog limited by
     * the <b>from</b> and <b>to</b> constraints. For example, getting cards
     * from 4 to 6 returns cards #5 (index 4), #6 (index 5) and #7 (index 6).
     * 
     * @param catalog
     * catalog
     * @param batch
     * batch
     * @param from
     * index from (starting from 0)
     * @param to
     * index to (starting from 0)
     * @return a list of cards
     * @throws GeneralRepositoryException
     * general exception
     */
    public List<String> getCardIdsInRange(final Catalog catalog, final String batch, final int from, final int to) throws GeneralRepositoryException {
        return this.getCardIds(catalog, batch, from, to - from + 1);
    }
    
    /**
     * Returns a list of cards which have the given file associated with them
     * (located in the right property).
     * 
     * @param file
     * file name
     * @return list of cards which have the given file
     * @throws GeneralRepositoryException
     * general exception
     * @throws NotFoundRepositoryException
     * not found exception
     */
    public List<String> getCardIdsWithFile(final String file) throws NotFoundRepositoryException, GeneralRepositoryException {
        // PREPARE QUERY
        
        final Options options = new Options().key(file);
        
        // RETURN RESULTS
        
        return this.loadDocumentIds(CardRepository.V_FILES, options);
    }
    
    /**
     * Finds and returns a list of IDs of cards which were rewritten by the
     * given user and their state equals to "REWRITTEN". Any other card states
     * are ignored.
     * 
     * @param userId
     * user ID
     * @return list of card IDs
     * @throws GeneralRepositoryException
     * general repository exception
     */
    public List<String> getCardIdsFixedByUser(final String userId) throws GeneralRepositoryException {
        CardRepository.LOG.debug(String.format("Finding OCR fixed by user '%s'...", userId));
        final Options options = new Options().key(userId);
        return this.loadDocumentIds(CardRepository.V_REWRITES, options);
    }
    
    /**
     * Returns the list of all batches. Each batch is represented by a triple
     * (catalog, batch for sort, batch). The original sorting order of the list
     * is not correct by the Czech rules, because it is sorted by the CouchDB
     * database. That is why the loaded list is sorted again with the
     * CzechAlphabet comparator.
     * 
     * @see CzechAlphabet
     * @return list of batches in triple (catalog, batch for sort, batch name)
     * sorted by the correct Czech rules
     * @throws GeneralRepositoryException
     * general exception
     */
    public List<BatchMetainfo> getSortedBatches() throws GeneralRepositoryException {
        CardRepository.LOG.debug("Loading all batches with metainfo...");
        
        final List<BatchMetainfo> list = new ArrayList<BatchMetainfo>(8 * 1024);
        
        for (final Catalog icatalog : Catalog.values()) {
            CardRepository.LOG.info(String.format("Loading batches for catalog: %s", icatalog.name()));
            
            // create batch name set
            
            final Set<String> visited = new HashSet<String>();
            
            // create options
            
            final Object startKey = Arrays.asList(icatalog.name());
            final Object endKey = Arrays.asList(icatalog.name(), Collections.emptyMap());
            
            final Options options = new Options().group(true).startKey(startKey).endKey(endKey);
            
            // query database
            
            @SuppressWarnings("rawtypes")
            final ViewResult<Map> result = this.queryView(CardRepository.V_BATCHES, Map.class, options);
            
            for (@SuppressWarnings("rawtypes")
            final ValueRow<Map> row : result.getRows()) {
                // type key to a list
                final List<?> key = (List<?>) row.getKey();
                // catalog is stored in the key at index 0
                final Catalog catalog = Catalog.valueOf((String) key.get(0));
                // batch for sort name is stored in the key at index 1
                final String batchForSort = (String) key.get(1);
                // batch name is stored in the key at index 2
                final String batch = (String) key.get(2);
                // map is stored in the value
                final Map<?, ?> map = row.getValue();
                // first batch card number is stored in the value
                final int firstCardNumber = ((Number) map.get("min")).intValue();
                // get the count
                final int count = ((Number) map.get("count")).intValue();
                // get the real number sum
                final int realSum = ((Number) map.get("sum")).intValue();
                // get the expected number sum (arithmetic sequence sum)
                final int theorySum = (count + count * count) / 2;
                // continuity flag
                final boolean continous = (realSum == theorySum);
                
                if (!visited.contains(batch)) {
                    // add batch to the list
                    
                    list.add(new BatchMetainfo(catalog, batch, batchForSort, firstCardNumber, continous));
                    
                    // ensure each batch is only once in the list
                    
                    visited.add(batch);
                } else {
                    // non-distinct batch
                    
                    CardRepository.LOG.warn(String.format("Already visited batch '%s' will be skipped.", batch));
                }
            }
            
            CardRepository.LOG.info(String.format("%d distinct batch(es) loaded from catalog.", visited.size()));
        }
        
        // sort the list
        
        CardRepository.LOG.info(String.format("Sorting %d batch(es)...", list.size()));
        
        Collections.sort(list, new Comparator<BatchMetainfo>() {
            @Override
            public int compare(final BatchMetainfo o1, final BatchMetainfo o2) {
                // sorting here is done by comparing the batch for sort
                
                return CzechAlphabet.getInstance().compare(o1.getNameForSort(), o2.getNameForSort());
            }
        });
        
        // return the list
        
        CardRepository.LOG.info(String.format("%d batch(es) sorted and ready for use.", list.size()));
        return Collections.unmodifiableList(list);
    }
    
    /**
     * Returns the number of cards in the given batch and catalog.
     * 
     * @param catalog
     * catalog
     * @param batch
     * batch
     * @return number of cards in the batch
     * @throws GeneralRepositoryException
     * general exception
     */
    public int getBatchSize(final Catalog catalog, final String batch) throws GeneralRepositoryException {
        CardRepository.LOG.debug(String.format("Counting cards in batch '%s' in catalog '%s'...", batch, catalog));
        
        // prepare query
        
        final Object key = new Object[] { catalog.name(), batch };
        
        final Options options = new Options().group(true).key(key);
        
        // run the query
        
        final ViewResult<Integer> result = this.queryView(CardRepository.V_BATCHES_SIZE, Integer.class, options);
        
        // process results
        
        if (result.getRows().size() < 1) {
            CardRepository.LOG.debug("There are no cards in this batch.");
            return 0;
        }
        
        // return results
        
        return result.getRows().get(0).getValue();
    }
    
    /**
     * Renumbers all cards in the given batch keeping their current order. The
     * renumbering causes all card numbers to be overridden by a continuous
     * natural number series (1 to N), which closes all possible remaining gaps
     * of any size that are in the batch. For example,
     * <code>1,2,5,6,9,10,15,16</code> will be renumbered to
     * <code>1,2,3,4,5,6,7,8</code>.
     * 
     * @param catalog
     * catalog
     * @param batch
     * batch in the catalog
     * @throws GeneralRepositoryException
     * general exception
     * @throws NotFoundRepositoryException
     * not found exception
     */
    public void renumberBatch(final Catalog catalog, final String batch) throws GeneralRepositoryException, NotFoundRepositoryException {
        CardRepository.LOG.debug(String.format("Renumbering batch '%s' in catalog '%s'...", batch, catalog.toString()));
        
        // load all cards in the batch and sort
        
        final List<Card> cards = new ArrayList<Card>(this.loadDocuments(Card.class, this.getCardIdsInBatch(catalog, batch)));
        SimpleGeneralUtils.sortByNumberAndTime(cards);
        
        // assign new number to each card and save it
        
        int newNumber = 1;
        int count = 0;
        
        for (final Card card : cards) {
            // get old number
            
            final int oldNumber = card.getNumberInBatch();
            
            // set the new number and update the card
            
            if (newNumber != oldNumber) {
                CardRepository.LOG.debug(String.format("Card number changed from #%d to #%d.", oldNumber, newNumber));
                card.setNumberInBatch(newNumber);
                this.updateCard(card);
                count++;
            }
            
            // increment number
            
            newNumber++;
        }
        
        CardRepository.LOG.debug(String.format("Renumbered %d card(s).", count));
    }
    
    @Override
    public Map<String, View> createViews() {
        final Map<String, View> views = new HashMap<String, View>();
        
        // -------------
        // BATCH LISTING
        // -------------
        
        // key = [catalog, batch]
        // value = card count
        
        views.put(CardRepository.V_BATCHES_SIZE, new View(
                "" +
                        "function(doc) {\n" +
                        "  if (doc.TAG_card) {\n" +
                        "    emit([doc.catalog, doc.batch], 1);\n" +
                        "  }\n" +
                        "}\n",
                "" +
                        "function(keys, values) {\n" +
                        "  return sum(values);\n" +
                        "}\n"));
        
        // key = [catalog, batch for sort, batch]
        // value = [first card number, numbering is continuous flag]
        
        views.put(CardRepository.V_BATCHES, new View(
                "" +
                        "function(doc) {\n" +
                        "  if (doc.TAG_card) {\n" +
                        "    emit([doc.catalog, doc.batch_sort, doc.batch], doc.nr);\n" +
                        "  }\n" +
                        "}\n",
                "" +
                        "_stats"));
        
        // ------------
        // CARD LISTING
        // ------------
        
        // key = [catalog, batch, card number]
        // value = card ID
        
        views.put(CardRepository.V_CARDS, new View(
                "" +
                        "function(doc) {\n" +
                        "  if (doc.TAG_card) {\n" +
                        "    emit([doc.catalog, doc.batch, doc.nr], doc._id);\n" +
                        "  }\n" +
                        "}\n"));
        
        // key = ID of the last user who fixed the card OCR
        // value = card ID (only rewritten cards are returned)
        
        views.put(CardRepository.V_REWRITES, new View(
                "" +
                        "function(doc) {\n" +
                        "  if (doc.TAG_card && doc.ocr_fix_user_id && doc.state == '" + CardState.REWRITTEN.name() + "') {\n" +
                        "    emit (doc.ocr_fix_user_id, doc._id);\n" +
                        "  }\n" +
                        "}\n"));
        
        // ------------------
        // IMAGE FILE LISTING
        // ------------------
        
        // key = file name
        // value = card ID
        
        views.put(CardRepository.V_FILES, new View(
                "" +
                        "function(doc) {\n" +
                        "  if (doc.TAG_card) {\n" +
                        "    for (var k in doc.files) {\n" +
                        "      emit (doc.files[k], doc._id);\n" +
                        "    }\n" +
                        "  }\n" +
                        "}\n"));
        
        return Collections.unmodifiableMap(views);
    }
}
